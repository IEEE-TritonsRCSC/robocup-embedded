# Drivetrain Firmware (STM32F4) — Deep Dive

This document explains the drivetrain firmware under `Core` for the STM32F4 board in depth: what each module does, how they interact, and the theory behind key subsystems (CAN, PID, timing, interrupts). It is intended for onboarding new team members and as a reference for maintainers.

The code lives in:
- `robocup-embedded/src/drivetrain/Core/Inc` — public headers and board-level defines
- `robocup-embedded/src/drivetrain/Core/Src` — implementation files
- `robocup-embedded/src/drivetrain/Core/Startup` — Cortex-M4 startup (vector table, reset)

At a high level, this MCU closes the wheel-speed control loop. It accepts velocity commands from the ESP32 over UART, updates PID controllers from motor feedback (received over CAN), and drives motors via CAN.

## System Overview
- Upstream: ESP32 receives teleop/AI commands over Wi‑Fi and forwards a compact frame over UART2 to the STM32.
- STM32 main loop:
  - Parses UART frames in an interrupt-driven state machine (header + payload).
  - Updates per‑wheel PID targets and computes control outputs at ~100 Hz.
  - Sends the motor setpoints on the CAN bus (two frames: 0x200 for 4 motors, 0x1FF for the “dribbler”).
  - Enforces a safety timeout that zeros targets on comms loss.
- Feedback: Motors publish encoder/speed over CAN with standard IDs 0x201..0x204; ISR stores latest values for the PID loop.
- Timing base: HAL tick is provided by TIM6 at 1 ms; the app loop delays with `HAL_Delay(10)`.

Key protocols and formats:
- UART frame from ESP32 → STM32:
  - Header: 0xCA 0xFE
  - Payload (9 bytes): 4× int16_t wheel speeds (big‑endian), 1 byte dribbler flag
- CAN frames (to motors):
  - StdId 0x200, DLC=8: 4× int16 high/low bytes (motors 1..4)
  - StdId 0x1FF, DLC=8: uses bytes 0–1 for dribbler value; other bytes unused

Wheel index mapping (and CAN IDs):
- 0: Front Right (FR) → 0x201
- 1: Back Right (BR) → 0x202
- 2: Back Left (BL) → 0x203
- 3: Front Left (FL) → 0x204

## Theory Background

### CAN (Controller Area Network)
CAN is a multi‑drop, differential, real‑time field bus designed for robust operation in noisy environments. It provides prioritized, collision‑free message arbitration at the physical/data link layer. In our robot:
- The STM32 acts as a CAN controller, sending desired setpoints and receiving feedback from motor drivers.
- Each motor driver publishes feedback (angle, speed, torque current) on fixed standard IDs (0x201..0x204).
- The STM32 sends command frames with StdId 0x200 (DJI‑style convention for commanding 4 motors per frame) and 0x1FF (commonly used for IDs 5..8 — we use it for the dribbler).
- Benefits: robust wiring, low EMI susceptibility, and deterministic arbitration.

### PID Control
A Proportional‑Integral‑Derivative controller computes a control output to minimize error between a target and a measured value.
- Proportional: pushes proportionally to the current error.
- Integral: accumulates past error to remove steady‑state offset (with anti‑windup clamping).
- Derivative: damps response using the error derivative.
In this firmware, each wheel has a PID (`motor_pid[0..3]`) that takes speed (from CAN feedback) and produces a command used in the CAN transmit frames.

### Timing and Interrupts
- HAL tick (1 ms) is generated by TIM6 (`stm32f4xx_hal_timebase_tim.c`), not SysTick, freeing SysTick for other uses if needed.
- Receive paths use interrupts:
  - CAN FIFO0 pending ISR copies feedback into arrays (angle/speed/torque).
  - UART2 ISR implements a small state machine to parse a framed message (0xCA, 0xFE, then 9 bytes).
- The main loop runs every ~10 ms (`HAL_Delay(10)`), executing PID and sending commands.

## File-by-File Documentation (functions and roles)

### Core/Inc/main.h
Defines board‑level pins and public prototypes used by `main.c`:
- Pins: key input, LEDs, motor enable pins (`MOTOR1_PIN..MOTOR5_PIN` on `GPIOH`).
- LED macros: `LED_ON`, `LED_OFF` (note: active‑low LEDs).
- Prototypes: `setMotorSpeeds(...)`, `runMotors(...)`, `Error_Handler()`. Also declares movement helpers and dribbler helpers (`forward`, `backward`, `left`, `right`, `dribble`, `noDribble`) that are currently not implemented in `Core/Src` (leftovers/placeholders).

### Core/Src/main.c
Application entry point and control loop. Key globals:
- CAN transmit/receive headers and data buffers; feedback arrays `angle_data[4]`, `speed_data[4]`, `torque_current_data[4]`.
- PID controllers `motor_pid[4]` with per‑wheel gains `Kp[1..4]`, `Ki[1..4]`, `Kd[1..4]`.
- UART receive state: `rx_byte`, `header1_flag`, `header2_flag`, `uart_rx_buffer[9]`.
- Safety: `timeout` increments each loop and resets on valid UART messages.
- Dribbler: `dribble_flag`, constant `DRIBBLE_SPEED`.

Functions:
- `int main(void)`
  - Initializes HAL, clocks, GPIO, DMA, CAN, TIM1, UART2.
  - Configures CAN TX headers: `StdId=0x200` (motors 1–4), `StdId=0x1FF` (dribbler), DLC=8.
  - Initializes PID controllers (`pid_init`) and target speeds to zero.
  - Arms UART2 interrupt reception: `HAL_UART_Receive_IT(&huart2, &rx_byte, 1)`.
  - Loop at ~100 Hz:
    - Sets `dribble_speed` based on `dribble_flag` (0 or `DRIBBLE_SPEED`).
    - If `timeout >= 200` (~2.0 s), zeros all `targetSpeeds` (safety stop on comms loss).
    - For each wheel, sets `motor_pid[i].target = targetSpeeds[i]` and calls `pid_calculate(&motor_pid[i], speed_data[i])`.
    - Calls `setMotorSpeeds(motor_pid[0].output, ..., motor_pid[3].output, dribble_speed)` to publish commands via CAN.
    - Increments `timeout` and sleeps 10 ms.

- `void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)`
  - Invoked on CAN RX FIFO0 message pending interrupt.
  - Reads message header/data into `canRxHeader`/`CAN_RxData`.
  - Maps `StdId` to wheel index (0x201→0, 0x202→1, 0x203→2, 0x204→3).
  - Parses fields:
    - `angle_data[idx] = (CAN_RxData[0] << 8) | CAN_RxData[1]`
    - `speed_data[idx] = (int16_t)((CAN_RxData[2] << 8) | CAN_RxData[3])`
    - `torque_current_data[idx] = (CAN_RxData[4] << 8) | CAN_RxData[5]`

- `void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)`
  - Interrupt‑driven UART receive state machine for framed messages:
    - Wait for header byte 1 (0xCA) into `rx_byte` → set `header1_flag`.
    - When `header1_flag` is set, wait for header byte 2 (0xFE): set `header2_flag` and trigger reception of 9‑byte payload into `uart_rx_buffer` with `HAL_UART_Receive_IT(&huart2, uart_rx_buffer, UART_RX_BUFFER_SIZE)`.
    - Once payload is received (callback again with `header2_flag` set):
      - Reset `timeout = 0` (comms healthy).
      - Parse 4× int16 speeds (big‑endian) into `targetSpeeds[0..3]`.
      - If `uart_rx_buffer[8] == DRIBBLE_ON (0x01)`, set `dribble_flag = 1`, else 0.
      - Clear `uart_rx_buffer` contents, toggle green LED, reset header flags, and re‑arm RX for a single byte.
    - If the second header byte does not match 0xFE, reset state and re‑arm single‑byte RX.

- `void SystemClock_Config(void)`
  - Configures the system clock to run from HSE with PLL (PLLM=6, PLLN=168, PLLP=2) to 168 MHz core, APB1=42 MHz, APB2=84 MHz.

- `void setMotorSpeeds(int16_t ms1, int16_t ms2, int16_t ms3, int16_t ms4, int16_t msg5)`
  - Splits each 16‑bit value into high/low bytes and calls `runMotors(...)`.

- `void runMotors(unsigned char h1, unsigned char l1, ..., unsigned char h5, unsigned char l5)`
  - Packs bytes for motors 1–4 into `CAN_TxData[0..7]`, dribbler into `CAN2_TxData[0..1]`.
  - Transmits two CAN frames via `HAL_CAN_AddTxMessage`: one on `0x200` (4 motors), one on `0x1FF` (dribbler).

- `void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)`
  - Increments HAL tick when TIM6 update occurs (`HAL_IncTick()`), supporting `HAL_Delay`.

- `void Error_Handler(void)`
  - Disables interrupts and loops forever; standard HAL error trap.

- `void assert_failed(uint8_t *file, uint32_t line)` (only if `USE_FULL_ASSERT`)
  - Stub to report assertion failures.

Notes:
- `forward/backward/left/right/dribble/noDribble` are declared in `main.h` but not implemented; remove or implement as needed.
- `REDUCTION_RATIO` is defined but unused in current control path.

### Core/Inc/PID.h and Core/Src/PID.c
Simple direct‑form PID with anti‑windup and output clamping.

- `void pid_init(PID_TypeDef *pid, float maxout, float integral_limit, float deadband, float target, float kp, float ki, float kd)`
  - Initializes limits, initial target, and gains; zeros output. The `deadband` field is stored but not used in current compute routine.

- `void pid_set_constants(PID_TypeDef *pid, float kp, float ki, float kd)`
  - Updates gains at runtime.

- `float pid_calculate(PID_TypeDef *pid, float measure)`
  - Computes `error = target - measure`.
  - `pout = kp * error`.
  - Integrates error with clamping to `[-IntegralLimit, +IntegralLimit]`; `iout = ki * integral`.
  - `dout = kd * (error - last_error)` (simple discrete derivative on error).
  - `output = pout + iout + dout` with clamping to `[-MaxOutput, +MaxOutput]`.
  - Returns `output`.

Tuning tip: start with P only for responsiveness, add small I for steady‑state error, and use D sparingly to damp overshoot. Monitor `speed_data[]` vs `targetSpeeds[]` to adjust gains per wheel.

### Core/Inc/can.h and Core/Src/can.c
Configures and operates the CAN1 peripheral.

- Globals:
  - `CAN_HandleTypeDef hcan1` — handle for CAN1
  - `CAN_FilterTypeDef canfilter1` — RX filter configuration

- `void MX_CAN1_Init(void)`
  - Initializes CAN1 with prescaler=3, segments BS1=9TQ, BS2=4TQ, SJW=1TQ in normal mode, auto bus‑off enabled.
  - Configures a permissive 32‑bit mask filter (accept all) routed to FIFO0.
  - Starts CAN and enables RX FIFO0 message pending interrupts.

- `void HAL_CAN_MspInit(CAN_HandleTypeDef *canHandle)` / `void HAL_CAN_MspDeInit(CAN_HandleTypeDef *canHandle)`
  - Low‑level MSP: clocks, PD0 (RX) / PD1 (TX) alternate functions (AF9), and NVIC priorities for CAN TX/RX0 IRQs.

Theory: The chosen bit timing must match the motor drivers’ bitrate (e.g., 1 Mbps typical for DJI ESCs). The wide‑open filter simplifies development; for production, filter by expected IDs for robustness.

### Core/Inc/usart.h and Core/Src/usart.c
Configures USART2 used for the ESP32 bridge.

- Globals: `UART_HandleTypeDef huart2`.
- `void MX_USART2_UART_Init(void)` — 115200‑8N1, TX/RX enabled.
- `void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)` / `DeInit` — PD5 (TX) / PD6 (RX) as AF7, enables USART2 clock and NVIC IRQ.

Usage: RX is interrupt‑driven via `HAL_UART_Receive_IT` and `HAL_UART_RxCpltCallback` in `main.c`.

### Core/Inc/tim.h and Core/Src/tim.c
TIM1 input capture configuration (not currently used in the main control loop) and DMA for capture channels.

- Globals: `TIM_HandleTypeDef htim1`, `DMA_HandleTypeDef hdma_tim1_ch1_ch2_ch3`.
- `void MX_TIM1_Init(void)` — sets up TIM1 IC channels (CH2 direct, CH1/CH4 indirect; CH2 on both edges, others rising), master config disabled.
- MSP init/deinit configures GPIOs: PA9 (TIM1_CH2), PE13 (TIM1_CH3), and sets up DMA2 Stream6 for TIM1 CC1/CC2/CC3 in circular mode.

Note: This looks prepared for input capture measurement (e.g., encoder/frequency capture) but the main loop currently uses CAN feedback. Treat this as optional future expansion.

### Core/Inc/gpio.h and Core/Src/gpio.c
Initializes GPIO clocks and pins.

- Enables clocks for all relevant ports (A..H).
- Sets initial states for LEDs and motor control pins.
- Configures:
  - Motor pins (`MOTOR1_PIN..MOTOR5_PIN` on `MOTOR_PORT`) as push‑pull outputs.
  - Key pin (`KEY_PIN` on `KEY_PORT`) as input.
  - `LED_GREEN_PIN` and `LED_RED_PIN` as outputs.

### Core/Inc/dma.h and Core/Src/dma.c
Enables DMA2 and configures NVIC for `DMA2_Stream6_IRQn`. TIM1 capture uses this stream.

- `void MX_DMA_Init(void)` — enables DMA2 clock, sets NVIC priority for Stream6.

### Core/Src/stm32f4xx_hal_msp.c
Board‑level MSP init:
- `void HAL_MspInit(void)` — enables SYSCFG and PWR clocks; place for global MSP customizations.

### Core/Src/stm32f4xx_hal_timebase_tim.c
Replaces SysTick with TIM6 for the HAL time base (1 ms tick).
- `HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)` — configures TIM6 to generate 1 kHz interrupts and sets NVIC priority.
- `void HAL_SuspendTick(void)` / `void HAL_ResumeTick(void)` — pause/resume tick by masking/unmasking TIM6 update IRQ.

### Core/Src/stm32f4xx_it.c
Interrupt service routines (ISRs) that dispatch to HAL drivers:
- Cortex‑M exceptions: `NMI_Handler`, `HardFault_Handler`, `MemManage_Handler`, `BusFault_Handler`, `DebugMon_Handler`, `PendSV_Handler`, `SysTick_Handler`.
- Peripheral IRQs: `CAN1_TX_IRQHandler`, `CAN1_RX0_IRQHandler`, `USART2_IRQHandler`, `TIM6_DAC_IRQHandler`, `DMA2_Stream6_IRQHandler` — all call into the corresponding HAL handler (e.g., `HAL_CAN_IRQHandler(&hcan1)`), which triggers user callbacks like `HAL_CAN_RxFifo0MsgPendingCallback` in `main.c`.

### Core/Src/system_stm32f4xx.c
CMSIS system file providing:
- `void SystemInit(void)` — early MCU init called from startup code, sets FPU access, vector table address.
- `void SystemCoreClockUpdate(void)` — updates `SystemCoreClock` based on RCC registers.
- Global clock tables and defaults.

### Core/Src/syscalls.c and Core/Src/sysmem.c
C library (newlib) minimal system call stubs for bare‑metal:
- `_write`, `_read` use weak hooks `__io_putchar/__io_getchar` (often mapped to UART for printf/scanf).
- Other POSIX stubs return errors as appropriate; `_sbrk` in `sysmem.c` grows the heap while preserving minimum stack space.

### Core/Startup/startup_stm32f427iihx.s
Toolchain‑provided startup (vector table, reset handler) that calls `SystemInit` then enters `main`. It defines weak ISR symbols overridden by our definitions in `stm32f4xx_it.c`.

## Control Loop and Data Flow (end-to-end)
1. ESP32 sends: `[0xCA, 0xFE] + 8 bytes (4× int16 speeds, big‑endian) + 1 byte dribbler flag`.
2. UART2 ISR in STM32 parses the frame; on valid payload:
   - Resets `timeout`.
   - Updates `targetSpeeds[0..3]` and `dribble_flag`.
3. CAN RX ISR updates `speed_data[]` from motor feedback as it arrives.
4. Every 10 ms in `main` loop:
   - `pid_calculate(target=targetSpeeds[i], measure=speed_data[i])` for each wheel.
   - `setMotorSpeeds(PID outputs..., dribble_speed)` packs and transmits CAN setpoints.
   - If `timeout >= 200` (≈2 s without UART), zero targets for safety.

## Safety, Diagnostics, and Tuning
- Safety timeout: guarantees the robot stops if the ESP32 link dies.
- LED feedback: green LED toggles on valid UART frames.
- PID tuning: start with moderate P, small I (0.01 as in code), D at 0; adjust per wheel based on overshoot/steady‑state error.
- CAN filters: consider filtering in `MX_CAN1_Init` to only accept expected IDs in competition environments.
- Throughput considerations: `HAL_CAN_AddTxMessage` returns status; for robustness you may want to check return values and queue retries on mailbox full.

## Extending and Maintenance Notes
- Unused declarations: remove or implement `forward/backward/left/right/dribble/noDribble` in `main.h`.
- TIM1 IC path: either wire it into measurement logic (if needed) or remove to simplify the project.
- Message format: if you change the UART payload (e.g., add checksum), update `UART_RX_BUFFER_SIZE` and the RX callback accordingly.
- Dribbler: `DRIBBLE_SPEED` is a fixed setpoint; consider proportional control to a desired RPM via CAN feedback if available.

## Quick Reference (where to look)
- UART RX state machine: `robocup-embedded/src/drivetrain/Core/Src/main.c:252`
- PID usage and control loop: `robocup-embedded/src/drivetrain/Core/Src/main.c:213`
- CAN config: `robocup-embedded/src/drivetrain/Core/Src/can.c:31`
- CAN RX parsing: `robocup-embedded/src/drivetrain/Core/Src/main.c:230`
- CAN TX packing (call): `robocup-embedded/src/drivetrain/Core/Src/main.c:216` (and implementation at `:356`)
- PID implementation: `robocup-embedded/src/drivetrain/Core/Src/PID.c:7`
